{"ast":null,"code":"import { encodeVersion } from \"./encodeVersion.js\";\nimport { getAnalyticsOptions } from \"./getAnalyticsOptions.js\";\nimport { packageVersion } from \"../internal/utils/packageVersion.js\";\n/**\r\n * @private\r\n * @description Try to get the node version out of process, if browser just return 0.0.0\r\n */\n\nfunction getNodeVersion() {\n  const failedVersion = '0.0.0';\n\n  if (typeof window !== 'undefined') {\n    return failedVersion;\n  } else {\n    // node env\n    try {\n      return process.versions.node || failedVersion;\n    } catch (e) {\n      return failedVersion;\n    }\n  }\n}\n/**\r\n * @private\r\n * @description Ensure that all values ITrackedPropertiesThroughAnalytics are populated.\r\n * Accept a partial map of values and returns the complete interface of ITrackedPropertiesThroughAnalytics\r\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\r\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\r\n */\n\n\nfunction ensureShapeOfTrackedProperties(trackedAnalytics) {\n  // try to get the process version from node, but if we're on the client return 0.0.0\n  const defaults = {\n    techVersion: getNodeVersion(),\n    sdkCode: 'T',\n    sdkSemver: packageVersion.split('-')[0],\n    responsive: false,\n    placeholder: false,\n    lazyload: false,\n    accessibility: false\n  };\n\n  if (!trackedAnalytics) {\n    return defaults;\n  } else {\n    return Object.assign(Object.assign({}, defaults), trackedAnalytics);\n  }\n}\n/**\r\n * @private\r\n * @description Creates the complete SDK signature by using all the values provided by ITrackedPropertiesThroughAnalytics\r\n *              Creation of the signature\r\n *              - Set the AlgoVersion of the encoding, this is an internal letter that represents the version\r\n *                of our encoding algorithm, it will allow us to perform breaking changes if we'll need them.\r\n *              - Take the constant SDK code (Arbitrary letter chosen for each SDK, for Base that letter is 'T')\r\n *                this is used to tell apart which SDK is being tracked.\r\n *              - Take the {major.minor} versions of the node version (techVersion) (14.2, 16.2 etc.)\r\n *              - Take the full semver of the SDK you wish to track\r\n *              - Take the features used(lazy, placeholder etc.) and turn them to a letter (for example accessibility -> D)\r\n *              - Before appending the string, the Versions must be encoded, see the function `encodeVersion` for more details\r\n *              - Append all the variables to a single string\r\n *              - In any case of an error, return the single letter 'E'\r\n *\r\n * @return {string} sdkAnalyticsSignature\r\n */\n\n\nexport function getSDKAnalyticsSignature(_trackedAnalytics) {\n  const trackedAnalytics = ensureShapeOfTrackedProperties(_trackedAnalytics);\n  const analyticsOptions = getAnalyticsOptions(trackedAnalytics);\n\n  try {\n    const twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n    const encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n    const encodedTechVersion = encodeVersion(twoPartVersion);\n    const featureCode = analyticsOptions.feature;\n    const SDKCode = analyticsOptions.sdkCode;\n    const algoVersion = 'A'; // The algo version is determined here, it should not be an argument\n\n    return `${algoVersion}${SDKCode}${encodedSDKVersion}${encodedTechVersion}${featureCode}`;\n  } catch (e) {\n    // Either SDK or Node versions were unparsable\n    return 'E';\n  }\n}\n/**\r\n * @private\r\n * @description Removes patch version from the semver if it exists\r\n *              Turns x.y.z OR x.y into x.y\r\n * @param {'x.y.z' | 'x.y' | string} semVerStr\r\n */\n\nfunction removePatchFromSemver(semVerStr) {\n  const parts = semVerStr.split('.');\n  return `${parts[0]}.${parts[1]}`;\n}","map":{"version":3,"sources":["C:/Users/Pham Tan Duong/Desktop/cloneGit/nhom6-csdlnc/fashion/node_modules/@cloudinary/url-gen/sdkAnalytics/getSDKAnalyticsSignature.js"],"names":["encodeVersion","getAnalyticsOptions","packageVersion","getNodeVersion","failedVersion","window","process","versions","node","e","ensureShapeOfTrackedProperties","trackedAnalytics","defaults","techVersion","sdkCode","sdkSemver","split","responsive","placeholder","lazyload","accessibility","Object","assign","getSDKAnalyticsSignature","_trackedAnalytics","analyticsOptions","twoPartVersion","removePatchFromSemver","encodedSDKVersion","encodedTechVersion","featureCode","feature","SDKCode","algoVersion","semVerStr","parts"],"mappings":"AAAA,SAASA,aAAT,QAA8B,oBAA9B;AACA,SAASC,mBAAT,QAAoC,0BAApC;AACA,SAASC,cAAT,QAA+B,qCAA/B;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,GAA0B;AACtB,QAAMC,aAAa,GAAG,OAAtB;;AACA,MAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;AAC/B,WAAOD,aAAP;AACH,GAFD,MAGK;AACD;AACA,QAAI;AACA,aAAOE,OAAO,CAACC,QAAR,CAAiBC,IAAjB,IAAyBJ,aAAhC;AACH,KAFD,CAGA,OAAOK,CAAP,EAAU;AACN,aAAOL,aAAP;AACH;AACJ;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,8BAAT,CAAwCC,gBAAxC,EAA0D;AACtD;AACA,QAAMC,QAAQ,GAAG;AACbC,IAAAA,WAAW,EAAEV,cAAc,EADd;AAEbW,IAAAA,OAAO,EAAE,GAFI;AAGbC,IAAAA,SAAS,EAAEb,cAAc,CAACc,KAAf,CAAqB,GAArB,EAA0B,CAA1B,CAHE;AAIbC,IAAAA,UAAU,EAAE,KAJC;AAKbC,IAAAA,WAAW,EAAE,KALA;AAMbC,IAAAA,QAAQ,EAAE,KANG;AAObC,IAAAA,aAAa,EAAE;AAPF,GAAjB;;AASA,MAAI,CAACT,gBAAL,EAAuB;AACnB,WAAOC,QAAP;AACH,GAFD,MAGK;AACD,WAAOS,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBV,QAAlB,CAAd,EAA2CD,gBAA3C,CAAP;AACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASY,wBAAT,CAAkCC,iBAAlC,EAAqD;AACxD,QAAMb,gBAAgB,GAAGD,8BAA8B,CAACc,iBAAD,CAAvD;AACA,QAAMC,gBAAgB,GAAGxB,mBAAmB,CAACU,gBAAD,CAA5C;;AACA,MAAI;AACA,UAAMe,cAAc,GAAGC,qBAAqB,CAACF,gBAAgB,CAACZ,WAAlB,CAA5C;AACA,UAAMe,iBAAiB,GAAG5B,aAAa,CAACyB,gBAAgB,CAACV,SAAlB,CAAvC;AACA,UAAMc,kBAAkB,GAAG7B,aAAa,CAAC0B,cAAD,CAAxC;AACA,UAAMI,WAAW,GAAGL,gBAAgB,CAACM,OAArC;AACA,UAAMC,OAAO,GAAGP,gBAAgB,CAACX,OAAjC;AACA,UAAMmB,WAAW,GAAG,GAApB,CANA,CAMyB;;AACzB,WAAQ,GAAEA,WAAY,GAAED,OAAQ,GAAEJ,iBAAkB,GAAEC,kBAAmB,GAAEC,WAAY,EAAvF;AACH,GARD,CASA,OAAOrB,CAAP,EAAU;AACN;AACA,WAAO,GAAP;AACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;;AACA,SAASkB,qBAAT,CAA+BO,SAA/B,EAA0C;AACtC,QAAMC,KAAK,GAAGD,SAAS,CAAClB,KAAV,CAAgB,GAAhB,CAAd;AACA,SAAQ,GAAEmB,KAAK,CAAC,CAAD,CAAI,IAAGA,KAAK,CAAC,CAAD,CAAI,EAA/B;AACH","sourcesContent":["import { encodeVersion } from \"./encodeVersion.js\";\r\nimport { getAnalyticsOptions } from \"./getAnalyticsOptions.js\";\r\nimport { packageVersion } from \"../internal/utils/packageVersion.js\";\r\n/**\r\n * @private\r\n * @description Try to get the node version out of process, if browser just return 0.0.0\r\n */\r\nfunction getNodeVersion() {\r\n    const failedVersion = '0.0.0';\r\n    if (typeof window !== 'undefined') {\r\n        return failedVersion;\r\n    }\r\n    else {\r\n        // node env\r\n        try {\r\n            return process.versions.node || failedVersion;\r\n        }\r\n        catch (e) {\r\n            return failedVersion;\r\n        }\r\n    }\r\n}\r\n/**\r\n * @private\r\n * @description Ensure that all values ITrackedPropertiesThroughAnalytics are populated.\r\n * Accept a partial map of values and returns the complete interface of ITrackedPropertiesThroughAnalytics\r\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\r\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\r\n */\r\nfunction ensureShapeOfTrackedProperties(trackedAnalytics) {\r\n    // try to get the process version from node, but if we're on the client return 0.0.0\r\n    const defaults = {\r\n        techVersion: getNodeVersion(),\r\n        sdkCode: 'T',\r\n        sdkSemver: packageVersion.split('-')[0],\r\n        responsive: false,\r\n        placeholder: false,\r\n        lazyload: false,\r\n        accessibility: false\r\n    };\r\n    if (!trackedAnalytics) {\r\n        return defaults;\r\n    }\r\n    else {\r\n        return Object.assign(Object.assign({}, defaults), trackedAnalytics);\r\n    }\r\n}\r\n/**\r\n * @private\r\n * @description Creates the complete SDK signature by using all the values provided by ITrackedPropertiesThroughAnalytics\r\n *              Creation of the signature\r\n *              - Set the AlgoVersion of the encoding, this is an internal letter that represents the version\r\n *                of our encoding algorithm, it will allow us to perform breaking changes if we'll need them.\r\n *              - Take the constant SDK code (Arbitrary letter chosen for each SDK, for Base that letter is 'T')\r\n *                this is used to tell apart which SDK is being tracked.\r\n *              - Take the {major.minor} versions of the node version (techVersion) (14.2, 16.2 etc.)\r\n *              - Take the full semver of the SDK you wish to track\r\n *              - Take the features used(lazy, placeholder etc.) and turn them to a letter (for example accessibility -> D)\r\n *              - Before appending the string, the Versions must be encoded, see the function `encodeVersion` for more details\r\n *              - Append all the variables to a single string\r\n *              - In any case of an error, return the single letter 'E'\r\n *\r\n * @return {string} sdkAnalyticsSignature\r\n */\r\nexport function getSDKAnalyticsSignature(_trackedAnalytics) {\r\n    const trackedAnalytics = ensureShapeOfTrackedProperties(_trackedAnalytics);\r\n    const analyticsOptions = getAnalyticsOptions(trackedAnalytics);\r\n    try {\r\n        const twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\r\n        const encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\r\n        const encodedTechVersion = encodeVersion(twoPartVersion);\r\n        const featureCode = analyticsOptions.feature;\r\n        const SDKCode = analyticsOptions.sdkCode;\r\n        const algoVersion = 'A'; // The algo version is determined here, it should not be an argument\r\n        return `${algoVersion}${SDKCode}${encodedSDKVersion}${encodedTechVersion}${featureCode}`;\r\n    }\r\n    catch (e) {\r\n        // Either SDK or Node versions were unparsable\r\n        return 'E';\r\n    }\r\n}\r\n/**\r\n * @private\r\n * @description Removes patch version from the semver if it exists\r\n *              Turns x.y.z OR x.y into x.y\r\n * @param {'x.y.z' | 'x.y' | string} semVerStr\r\n */\r\nfunction removePatchFromSemver(semVerStr) {\r\n    const parts = semVerStr.split('.');\r\n    return `${parts[0]}.${parts[1]}`;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}