{"ast":null,"code":"import Condition from './condition.js';\nimport { CONFIG_PARAMS } from './configuration.js';\nimport { cloneDeep } from '../internal/utils/cloneDeep.js';\nimport { camelCase, contains, difference } from \"./utils/legacyBaseUtil.js\";\nimport { snakeCase } from \"./utils/snakeCase.js\";\nimport Expression from './expression.js';\nimport Layer from './legacyLayer/layer.js';\nimport TextLayer from './legacyLayer/textlayer.js';\nimport SubtitlesLayer from './legacyLayer/subtitleslayer.js';\nimport FetchLayer from './legacyLayer/fetchlayer.js';\nimport { isObject } from \"./utils/isObject.js\";\nimport { isString } from \"../internal/utils/dataStructureUtils.js\";\nimport { isEmpty } from \"./utils/isEmpty.js\";\nimport { isFunction } from \"./utils/isFunction.js\";\nimport { identity, withCamelCaseKeys } from \"./utils/legacyBaseUtil.js\";\n/**\r\n * A list of keys used by the url() function.\r\n * @private\r\n */\n\nexport const URL_KEYS = ['accessibility', 'api_secret', 'auth_token', 'cdn_subdomain', 'cloud_name', 'cname', 'format', 'placeholder', 'private_cdn', 'resource_type', 'secure', 'secure_cdn_subdomain', 'secure_distribution', 'shorten', 'sign_url', 'signature', 'ssl_detected', 'type', 'url_suffix', 'use_root_path', 'version'];\n/**\r\n * Assign key, value to target, when value is not null.<br>\r\n *   This function mutates the target!\r\n * @param {object} target the object to assign the values to\r\n * @param {object} sources one or more objects to get values from\r\n * @returns {object} the target after the assignment\r\n */\n\nfunction assignNotNull(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  sources.forEach(source => {\n    Object.keys(source).forEach(key => {\n      // @ts-ignore\n      if (source[key] != null) {\n        // @ts-ignore\n        target[key] = source[key];\n      }\n    });\n  });\n  return target;\n}\n/**\r\n * Return true if all items in list are strings\r\n * @function Util.allString\r\n * @param {Array} list - an array of items\r\n */\n\n\nconst allStrings = function (list) {\n  return list.length && list.every(isString);\n};\n/**\r\n * Transformation parameters\r\n * Depends on 'util', 'transformation'\r\n */\n\n\nclass Param {\n  /**\r\n   * Represents a single parameter.\r\n   * @class Param\r\n   * @param {string} name - The name of the parameter in snake_case\r\n   * @param {string} shortName - The name of the serialized form of the parameter.\r\n   *                         If a value is not provided, the parameter will not be serialized.\r\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\r\n   * @ignore\r\n   */\n  constructor(name, shortName) {\n    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n\n    /**\r\n     * The name of the parameter in snake_case\r\n     * @member {string} Param#name\r\n     */\n    this.name = name;\n    /**\r\n     * The name of the serialized form of the parameter\r\n     * @member {string} Param#shortName\r\n     */\n\n    this.shortName = shortName;\n    /**\r\n     * Manipulate origValue when value is called\r\n     * @member {function} Param#process\r\n     */\n\n    this.process = process;\n  }\n  /**\r\n   * Set a (unprocessed) value for this parameter\r\n   * @function Param#set\r\n   * @param {*} origValue - the value of the parameter\r\n   * @return {Param} self for chaining\r\n   */\n\n\n  set(origValue) {\n    this.origValue = origValue;\n    return this;\n  }\n  /**\r\n   * Generate the serialized form of the parameter\r\n   * @function Param#serialize\r\n   * @return {string} the serialized form of the parameter\r\n   */\n\n\n  serialize() {\n    var val, valid;\n    val = this.value();\n    valid = Array.isArray(val) || isObject(val) || isString(val) ? !isEmpty(val) : val != null;\n\n    if (this.shortName != null && valid) {\n      return `${this.shortName}_${val}`;\n    } else {\n      return '';\n    }\n  }\n  /**\r\n   * Return the processed value of the parameter\r\n   * @function Param#value\r\n   */\n\n\n  value() {\n    return this.process(this.origValue);\n  }\n\n  static norm_color(value) {\n    return value != null ? value.replace(/^#/, 'rgb:') : void 0;\n  }\n\n  static build_array(arg) {\n    if (arg == null) {\n      return [];\n    } else if (Array.isArray(arg)) {\n      return arg;\n    } else {\n      return [arg];\n    }\n  }\n  /**\r\n   * Covert value to video codec string.\r\n   *\r\n   * If the parameter is an object,\r\n   * @param {(string|Object)} param - the video codec as either a String or a Hash\r\n   * @return {string} the video codec string in the format codec:profile:level\r\n   * @example\r\n   * vc_[ :profile : [level]]\r\n   * or\r\n   { codec: 'h264', profile: 'basic', level: '3.1' }\r\n   * @ignore\r\n   */\n\n\n  static process_video_params(param) {\n    var video;\n\n    switch (param.constructor) {\n      case Object:\n        video = \"\";\n\n        if ('codec' in param) {\n          video = param.codec;\n\n          if ('profile' in param) {\n            video += \":\" + param.profile;\n\n            if ('level' in param) {\n              video += \":\" + param.level;\n            }\n          }\n        }\n\n        return video;\n\n      case String:\n        return param;\n\n      default:\n        return null;\n    }\n  }\n\n}\n\nclass ArrayParam extends Param {\n  /**\r\n   * A parameter that represents an array.\r\n   * @param {string} name - The name of the parameter in snake_case.\r\n   * @param {string} shortName - The name of the serialized form of the parameter\r\n   *                         If a value is not provided, the parameter will not be serialized.\r\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\r\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\r\n   * @class ArrayParam\r\n   * @extends Param\r\n   * @ignore\r\n   */\n  constructor(name, shortName) {\n    let sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n    let process = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    super(name, shortName, process);\n    this.sep = sep;\n  }\n\n  serialize() {\n    if (this.shortName != null) {\n      let arrayValue = this.value();\n\n      if (isEmpty(arrayValue)) {\n        return '';\n      } else if (isString(arrayValue)) {\n        return `${this.shortName}_${arrayValue}`;\n      } else {\n        let flat = arrayValue.map(t => isFunction(t.serialize) ? t.serialize() : t).join(this.sep);\n        return `${this.shortName}_${flat}`;\n      }\n    } else {\n      return '';\n    }\n  }\n\n  value() {\n    if (Array.isArray(this.origValue)) {\n      return this.origValue.map(v => this.process(v));\n    } else {\n      return this.process(this.origValue);\n    }\n  }\n\n  set(origValue) {\n    if (origValue == null || Array.isArray(origValue)) {\n      return super.set(origValue);\n    } else {\n      return super.set([origValue]);\n    }\n  }\n\n}\n\nclass TransformationParam extends Param {\n  /**\r\n   * A parameter that represents a transformation\r\n   * @param {string} name - The name of the parameter in snake_case\r\n   * @param {string} [shortName='t'] - The name of the serialized form of the parameter\r\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\r\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\r\n   * @class TransformationParam\r\n   * @extends Param\r\n   * @ignore\r\n   */\n  constructor(name) {\n    let shortName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"t\";\n    let sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n    let process = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    super(name, shortName, process);\n    this.sep = sep;\n  }\n  /**\r\n   * Generate string representations of the transformation.\r\n   * @returns {*} Returns either the transformation as a string, or an array of string representations.\r\n   */\n\n\n  serialize() {\n    let result = '';\n    const val = this.value();\n\n    if (isEmpty(val)) {\n      return result;\n    } // val is an array of strings so join them\n\n\n    if (allStrings(val)) {\n      const joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n\n      if (!isEmpty(joined)) {\n        // in case options.transformation was not set with an empty string (val != ['']);\n        result = `${this.shortName}_${joined}`;\n      }\n    } else {\n      // Convert val to an array of strings\n      result = val.map(t => {\n        if (isString(t) && !isEmpty(t)) {\n          return `${this.shortName}_${t}`;\n        }\n\n        if (isFunction(t.serialize)) {\n          return t.serialize();\n        }\n\n        if (isObject(t) && !isEmpty(t)) {\n          return new Transformation(t).serialize();\n        }\n\n        return undefined;\n      }).filter(t => t);\n    }\n\n    return result;\n  }\n\n  set(origValue1) {\n    this.origValue = origValue1;\n\n    if (Array.isArray(this.origValue)) {\n      return super.set(this.origValue);\n    } else {\n      return super.set([this.origValue]);\n    }\n  }\n\n}\n\nconst number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\nconst offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\n\nclass RangeParam extends Param {\n  /**\r\n   * A parameter that represents a range\r\n   * @param {string} name - The name of the parameter in snake_case\r\n   * @param {string} shortName - The name of the serialized form of the parameter\r\n   *                         If a value is not provided, the parameter will not be serialized.\r\n   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\r\n   * @class RangeParam\r\n   * @extends Param\r\n   * @ignore\r\n   */\n  constructor(name, shortName) {\n    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeParam.norm_range_value;\n    super(name, shortName, process);\n  }\n\n  static norm_range_value(value) {\n    let offset = String(value).match(new RegExp('^' + offset_any_pattern + '$'));\n\n    if (offset) {\n      let modifier = offset[5] != null ? 'p' : '';\n      value = (offset[1] || offset[4]) + modifier;\n    }\n\n    return value;\n  }\n\n}\n\nclass RawParam extends Param {\n  constructor(name, shortName) {\n    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n    super(name, shortName, process);\n  }\n\n  serialize() {\n    return this.value();\n  }\n\n}\n\nclass LayerParam extends Param {\n  // Parse layer options\n  // @return [string] layer transformation string\n  // @private\n  value() {\n    if (this.origValue == null) {\n      return '';\n    }\n\n    let result;\n\n    if (this.origValue instanceof Layer) {\n      result = this.origValue;\n    } else if (isObject(this.origValue)) {\n      let layerOptions = withCamelCaseKeys(this.origValue); // @ts-ignore\n\n      if (layerOptions.resourceType === \"text\" || layerOptions.text != null) {\n        result = new TextLayer(layerOptions);\n      } else {\n        // @ts-ignore\n        if (layerOptions.resourceType === \"subtitles\") {\n          result = new SubtitlesLayer(layerOptions);\n        } else {\n          // @ts-ignore\n          if (layerOptions.resourceType === \"fetch\" || layerOptions.url != null) {\n            result = new FetchLayer(layerOptions);\n          } else {\n            result = new Layer(layerOptions);\n          }\n        }\n      }\n    } else if (isString(this.origValue)) {\n      if (/^fetch:.+/.test(this.origValue)) {\n        result = new FetchLayer(this.origValue.substr(6));\n      } else {\n        result = this.origValue;\n      }\n    } else {\n      result = '';\n    }\n\n    return result.toString();\n  }\n\n  static textStyle(layer) {\n    return new TextLayer(layer).textStyleIdentifier();\n  }\n\n}\n/**\r\n * TransformationBase\r\n * Depends on 'configuration', 'parameters','util'\r\n * @internal\r\n */\n\n\nclass TransformationBase {\n  /**\r\n   * The base class for transformations.\r\n   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\r\n   * @class TransformationBase\r\n   */\n  constructor(options) {\n    /** @private */\n\n    /** @private */\n    let parent;\n    let trans;\n    parent = void 0;\n    trans = {};\n    /**\r\n     * Return an options object that can be used to create an identical Transformation\r\n     * @function Transformation#toOptions\r\n     * @return {Object} Returns a plain object representing this transformation\r\n     */\n\n    this.toOptions = withChain => {\n      let opt = {};\n\n      if (withChain == null) {\n        withChain = true;\n      } // @ts-ignore\n\n\n      Object.keys(trans).forEach(key => opt[key] = trans[key].origValue);\n      assignNotNull(opt, this.otherOptions);\n\n      if (withChain && !isEmpty(this.chained)) {\n        let list = this.chained.map(tr => tr.toOptions());\n        list.push(opt);\n        opt = {};\n        assignNotNull(opt, this.otherOptions); // @ts-ignore\n\n        opt.transformation = list;\n      }\n\n      return opt;\n    };\n    /**\r\n     * Set a parent for this object for chaining purposes.\r\n     *\r\n     * @function Transformation#setParent\r\n     * @param {Object} object - the parent to be assigned to\r\n     * @returns {Transformation} Returns this instance for chaining purposes.\r\n     */\n\n\n    this.setParent = object => {\n      parent = object;\n\n      if (object != null) {\n        // @ts-ignore\n        this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n      }\n\n      return this;\n    };\n    /**\r\n     * Returns the parent of this object in the chain\r\n     * @function Transformation#getParent\r\n     * @protected\r\n     * @return {Object} Returns the parent of this object if there is any\r\n     */\n\n\n    this.getParent = () => {\n      return parent;\n    }; // Helper methods to create parameter methods\n    // These methods are defined here because they access `trans` which is\n    // a private member of `TransformationBase`\n\n    /** @protected */\n\n\n    this.param = (value, name, abbr, defaultValue, process) => {\n      if (process == null) {\n        if (isFunction(defaultValue)) {\n          process = defaultValue;\n        } else {\n          process = identity;\n        }\n      } // @ts-ignore\n\n\n      trans[name] = new Param(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n\n\n    this.rawParam = function (value, name, abbr, defaultValue, process) {\n      process = lastArgCallback(arguments); // @ts-ignore\n\n      trans[name] = new RawParam(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n\n\n    this.rangeParam = function (value, name, abbr, defaultValue, process) {\n      process = lastArgCallback(arguments); // @ts-ignore\n\n      trans[name] = new RangeParam(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n\n\n    this.arrayParam = function (value, name, abbr) {\n      let sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \":\";\n      let defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n      let process = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n      process = lastArgCallback(arguments); // @ts-ignore\n\n      trans[name] = new ArrayParam(name, abbr, sep, process).set(value);\n      return this;\n    };\n    /** @protected */\n\n\n    this.transformationParam = function (value, name, abbr) {\n      let sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n      let defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n      let process = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n      process = lastArgCallback(arguments); // @ts-ignore\n\n      trans[name] = new TransformationParam(name, abbr, sep, process).set(value);\n      return this;\n    };\n\n    this.layerParam = function (value, name, abbr) {\n      // @ts-ignore\n      trans[name] = new LayerParam(name, abbr).set(value);\n      return this;\n    }; // End Helper methods\n\n    /**\r\n     * Get the value associated with the given name.\r\n     * Get the value associated with the given name.\r\n     * @function Transformation#getValue\r\n     * @param {string} name - the name of the parameter\r\n     * @return {*} the processed value associated with the given name\r\n     * @description Use {@link get}.origValue for the value originally provided for the parameter\r\n     */\n\n\n    this.getValue = function (name) {\n      // @ts-ignore\n      let value = trans[name] && trans[name].value();\n      return value != null ? value : this.otherOptions[name];\n    };\n    /**\r\n     * Get the parameter object for the given parameter name\r\n     * @function Transformation#get\r\n     * @param {string} name the name of the transformation parameter\r\n     * @returns {Param} the param object for the given name, or undefined\r\n     */\n\n\n    this.get = function (name) {\n      // @ts-ignore\n      return trans[name];\n    };\n    /**\r\n     * Remove a transformation option from the transformation.\r\n     * @function Transformation#remove\r\n     * @param {string} name - the name of the option to remove\r\n     * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\r\n     *              returned value depends on the value.\r\n     */\n\n\n    this.remove = function (name) {\n      var temp;\n\n      switch (false) {\n        // @ts-ignore\n        case trans[name] == null:\n          // @ts-ignore\n          temp = trans[name]; // @ts-ignore\n\n          delete trans[name];\n          return temp.origValue;\n\n        case this.otherOptions[name] == null:\n          temp = this.otherOptions[name];\n          delete this.otherOptions[name];\n          return temp;\n\n        default:\n          return null;\n      }\n    };\n    /**\r\n     * Return an array of all the keys (option names) in the transformation.\r\n     * @return {Array<string>} the keys in snakeCase format\r\n     */\n\n\n    this.keys = function () {\n      var key;\n      return function () {\n        var results;\n        results = [];\n\n        for (key in trans) {\n          if (key != null) {\n            results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n          }\n        }\n\n        return results;\n      }().sort();\n    };\n    /**\r\n     * Returns a plain object representation of the transformation. Values are processed.\r\n     * @function Transformation#toPlainObject\r\n     * @return {Object} the transformation options as plain object\r\n     */\n\n\n    this.toPlainObject = function () {\n      var hash, key, list;\n      hash = {};\n\n      for (key in trans) {\n        // @ts-ignore\n        hash[key] = trans[key].value(); // @ts-ignore\n\n        if (isObject(hash[key])) {\n          // @ts-ignore\n          hash[key] = cloneDeep(hash[key]);\n        }\n      }\n\n      if (!isEmpty(this.chained)) {\n        list = this.chained.map(tr => tr.toPlainObject());\n        list.push(hash);\n        hash = {\n          transformation: list\n        };\n      }\n\n      return hash;\n    };\n    /**\r\n     * Complete the current transformation and chain to a new one.\r\n     * In the URL, transformations are chained together by slashes.\r\n     * @function Transformation#chain\r\n     * @return {Transformation} Returns this transformation for chaining\r\n     * @example\r\n     * var tr = cloudinary.Transformation.new();\r\n     * tr.width(10).crop('fit').chain().angle(15).serialize()\r\n     * // produces \"c_fit,w_10/a_15\"\r\n     */\n\n\n    this.chain = function () {\n      var names, tr;\n      names = Object.getOwnPropertyNames(trans);\n\n      if (names.length !== 0) {\n        tr = new this.constructor(this.toOptions(false));\n        this.resetTransformations();\n        this.chained.push(tr);\n      }\n\n      return this;\n    };\n\n    this.resetTransformations = function () {\n      trans = {};\n      return this;\n    };\n\n    this.otherOptions = {};\n    this.chained = [];\n    this.fromOptions(options);\n  }\n  /**\r\n   * Merge the provided options with own's options\r\n   * @param {Object} [options={}] key-value list of options\r\n   * @returns {Transformation} Returns this instance for chaining\r\n   */\n\n\n  fromOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options instanceof TransformationBase) {\n      this.fromTransformation(options);\n    } else {\n      if (isString(options) || Array.isArray(options)) {\n        options = {\n          transformation: options\n        };\n      }\n\n      options = cloneDeep(options); // Handling of \"if\" statements precedes other options as it creates a chained transformation\n      // @ts-ignore\n\n      if (options[\"if\"]) {\n        // @ts-ignore\n        this.set(\"if\", options[\"if\"]); // @ts-ignore\n\n        delete options[\"if\"];\n      }\n\n      for (let key in options) {\n        // @ts-ignore\n        let opt = options[key];\n\n        if (opt != null) {\n          if (key.match(VAR_NAME_RE)) {\n            if (key !== '$attr') {\n              this.set('variable', key, opt);\n            }\n          } else {\n            this.set(key, opt);\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n\n  fromTransformation(other) {\n    if (other instanceof TransformationBase) {\n      other.keys().forEach(key => this.set(key, other.get(key).origValue));\n    }\n\n    return this;\n  }\n  /**\r\n   * Set a parameter.\r\n   * The parameter name `key` is converted to\r\n   * @param {string} key - the name of the parameter\r\n   * @param {*} values - the value of the parameter\r\n   * @returns {Transformation} Returns this instance for chaining\r\n   */\n\n\n  set(key) {\n    let camelKey;\n    camelKey = camelCase(key);\n\n    for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      values[_key2 - 1] = arguments[_key2];\n    }\n\n    if (contains(methods, camelKey)) {\n      // @ts-ignore\n      this[camelKey].apply(this, values);\n    } else {\n      this.otherOptions[key] = values[0];\n    }\n\n    return this;\n  }\n\n  hasLayer() {\n    return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n  }\n  /**\r\n   * Generate a string representation of the transformation.\r\n   * @function Transformation#serialize\r\n   * @return {string} Returns the transformation as a string\r\n   */\n\n\n  serialize() {\n    var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n    resultArray = this.chained.map(tr => tr.serialize());\n    paramList = this.keys();\n    transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n    ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n    variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n    paramList = difference(paramList, [\"transformation\", \"if\", \"variables\"]);\n    vars = [];\n    transformationList = [];\n\n    for (j = 0, len = paramList.length; j < len; j++) {\n      t = paramList[j];\n\n      if (t.match(VAR_NAME_RE)) {\n        vars.push(t + \"_\" + Expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n      } else {\n        transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n      }\n    }\n\n    switch (false) {\n      case !isString(transformations):\n        transformationList.push(transformations);\n        break;\n\n      case !Array.isArray(transformations):\n        resultArray = resultArray.concat(transformations);\n    }\n\n    transformationList = function () {\n      var k, len1, results;\n      results = [];\n\n      for (k = 0, len1 = transformationList.length; k < len1; k++) {\n        value = transformationList[k];\n\n        if (Array.isArray(value) && !isEmpty(value) || !Array.isArray(value) && value) {\n          results.push(value);\n        }\n      }\n\n      return results;\n    }();\n\n    transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n\n    if (ifParam === \"if_end\") {\n      transformationList.push(ifParam);\n    } else if (!isEmpty(ifParam)) {\n      transformationList.unshift(ifParam);\n    }\n\n    transformationString = transformationList.filter(x => !!x).join(param_separator);\n\n    if (!isEmpty(transformationString)) {\n      resultArray.push(transformationString);\n    }\n\n    return resultArray.filter(x => !!x).join(trans_separator);\n  }\n  /**\r\n   * Provide a list of all the valid transformation option names\r\n   * @function Transformation#listNames\r\n   * @private\r\n   * @return {Array<string>} a array of all the valid option names\r\n   */\n\n\n  static listNames() {\n    return methods;\n  }\n  /**\r\n   * Returns the attributes for an HTML tag.\r\n   * @function Cloudinary.toHtmlAttributes\r\n   * @return PlainObject\r\n   */\n\n\n  toHtmlAttributes() {\n    let attrName, height, options, ref2, ref3, value, width;\n    options = {};\n    let snakeCaseKey;\n    Object.keys(this.otherOptions).forEach(key => {\n      value = this.otherOptions[key];\n      snakeCaseKey = snakeCase(key);\n\n      if (!contains(PARAM_NAMES, snakeCaseKey) && !contains(URL_KEYS, snakeCaseKey)) {\n        attrName = /^html_/.test(key) ? key.slice(5) : key;\n        options[attrName] = value;\n      }\n    }); // convert all \"html_key\" to \"key\" with the same value\n\n    this.keys().forEach(key => {\n      if (/^html_/.test(key)) {\n        options[camelCase(key.slice(5))] = this.getValue(key);\n      }\n    });\n\n    if (!(this.hasLayer() || this.getValue(\"angle\") || contains([\"fit\", \"limit\", \"lfill\"], this.getValue(\"crop\")))) {\n      width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n      height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n\n      if (parseFloat(width) >= 1.0) {\n        if (options.width == null) {\n          options.width = width;\n        }\n      }\n\n      if (parseFloat(height) >= 1.0) {\n        if (options.height == null) {\n          options.height = height;\n        }\n      }\n    }\n\n    return options;\n  }\n\n  static isValidParamName(name) {\n    return methods.indexOf(camelCase(name)) >= 0;\n  }\n  /**\r\n   * Delegate to the parent (up the call chain) to produce HTML\r\n   * @function Transformation#toHtml\r\n   * @return {string} HTML representation of the parent if possible.\r\n   * @example\r\n   * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\r\n   * // ImageTag {name: \"img\", publicId: \"sample\"}\r\n   * tag.toHtml()\r\n   * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\r\n   * tag.transformation().crop(\"fit\").width(300).toHtml()\r\n   * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\r\n   */\n\n\n  toHtml() {\n    var ref;\n    return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n  }\n\n  toString() {\n    return this.serialize();\n  }\n\n  clone() {\n    return new TransformationBase(this.toOptions(true));\n  }\n\n}\n\nconst VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\nconst trans_separator = '/';\nconst param_separator = ',';\n\nfunction lastArgCallback(args) {\n  var callback;\n  callback = args != null ? args[args.length - 1] : void 0;\n\n  if (isFunction(callback)) {\n    return callback;\n  } else {\n    return void 0;\n  }\n}\n\nfunction processVar(varArray) {\n  var j, len, name, results, v;\n\n  if (Array.isArray(varArray)) {\n    results = [];\n\n    for (j = 0, len = varArray.length; j < len; j++) {\n      [name, v] = varArray[j];\n      results.push(`${name}_${Expression.normalize(v)}`);\n    }\n\n    return results;\n  } else {\n    return varArray;\n  }\n} // @ts-ignore\n\n\nfunction processCustomFunction(_ref) {\n  let {\n    function_type,\n    source\n  } = _ref;\n\n  if (function_type === 'remote') {\n    return [function_type, btoa(source)].join(\":\");\n  } else if (function_type === 'wasm') {\n    return [function_type, source].join(\":\");\n  }\n}\n/**\r\n * Transformation Class methods.\r\n * This is a list of the parameters defined in Transformation.\r\n * Values are camelCased.\r\n * @const Transformation.methods\r\n * @private\r\n * @ignore\r\n * @type {Array<string>}\r\n */\n\n/**\r\n * Parameters that are filtered out before passing the options to an HTML tag.\r\n *\r\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\r\n * @const {Array<string>} Transformation.PARAM_NAMES\r\n * @private\r\n * @ignore\r\n * @see toHtmlAttributes\r\n */\n\n\nclass Transformation extends TransformationBase {\n  /**\r\n   * Represents a single transformation.\r\n   * @class Transformation\r\n   * @example\r\n   * t = new cloudinary.Transformation();\r\n   * t.angle(20).crop(\"scale\").width(\"auto\");\r\n   *\r\n   * // or\r\n   *\r\n   * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\r\n   * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\r\n   *  target=\"_blank\">Available image transformations</a>\r\n   * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\r\n   *  target=\"_blank\">Available video transformations</a>\r\n   */\n  constructor(options) {\n    super(options);\n  }\n  /**\r\n   * Convenience constructor\r\n   * @param {Object} options\r\n   * @return {Transformation}\r\n   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\r\n   */\n\n\n  static new(options) {\n    return new Transformation(options);\n  }\n  /*\r\n    Transformation Parameters\r\n  */\n\n\n  angle(value) {\n    this.arrayParam(value, \"angle\", \"a\", \".\", Expression.normalize);\n    return this;\n  }\n\n  audioCodec(value) {\n    this.param(value, \"audio_codec\", \"ac\");\n    return this;\n  }\n\n  audioFrequency(value) {\n    this.param(value, \"audio_frequency\", \"af\");\n    return this;\n  }\n\n  aspectRatio(value) {\n    this.param(value, \"aspect_ratio\", \"ar\", Expression.normalize);\n    return this;\n  }\n\n  background(value) {\n    this.param(value, \"background\", \"b\", Param.norm_color);\n    return this;\n  }\n\n  bitRate(value) {\n    this.param(value, \"bit_rate\", \"br\");\n    return this;\n  }\n\n  border(value) {\n    return this.param(value, \"border\", \"bo\", border => {\n      if (isObject(border)) {\n        border = Object.assign({}, {\n          color: \"black\",\n          width: 2\n        }, border);\n        return `${border.width}px_solid_${Param.norm_color(border.color)}`;\n      } else {\n        return border;\n      }\n    });\n  }\n\n  color(value) {\n    this.param(value, \"color\", \"co\", Param.norm_color);\n    return this;\n  }\n\n  colorSpace(value) {\n    this.param(value, \"color_space\", \"cs\");\n    return this;\n  }\n\n  crop(value) {\n    this.param(value, \"crop\", \"c\");\n    return this;\n  }\n\n  customFunction(value) {\n    return this.param(value, \"custom_function\", \"fn\", () => {\n      return processCustomFunction(value);\n    });\n  }\n\n  customPreFunction(value) {\n    if (this.get('custom_function')) {\n      return;\n    }\n\n    return this.rawParam(value, \"custom_function\", \"\", () => {\n      value = processCustomFunction(value);\n      return value ? `fn_pre:${value}` : value;\n    });\n  }\n\n  defaultImage(value) {\n    this.param(value, \"default_image\", \"d\");\n    return this;\n  }\n\n  delay(value) {\n    this.param(value, \"delay\", \"dl\");\n    return this;\n  }\n\n  density(value) {\n    this.param(value, \"density\", \"dn\");\n    return this;\n  }\n\n  duration(value) {\n    this.rangeParam(value, \"duration\", \"du\");\n    return this;\n  }\n\n  dpr(value) {\n    return this.param(value, \"dpr\", \"dpr\", dpr => {\n      dpr = dpr.toString();\n\n      if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n        return dpr + \".0\";\n      } else {\n        return Expression.normalize(dpr);\n      }\n    });\n  }\n\n  effect(value) {\n    this.arrayParam(value, \"effect\", \"e\", \":\", Expression.normalize);\n    return this;\n  }\n\n  else() {\n    return this.if('else');\n  }\n\n  endIf() {\n    return this.if('end');\n  }\n\n  endOffset(value) {\n    this.rangeParam(value, \"end_offset\", \"eo\");\n    return this;\n  }\n\n  fallbackContent(value) {\n    this.param(value, \"fallback_content\");\n    return this;\n  }\n\n  fetchFormat(value) {\n    this.param(value, \"fetch_format\", \"f\");\n    return this;\n  }\n\n  format(value) {\n    this.param(value, \"format\");\n    return this;\n  }\n\n  flags(value) {\n    this.arrayParam(value, \"flags\", \"fl\", \".\");\n    return this;\n  }\n\n  gravity(value) {\n    this.param(value, \"gravity\", \"g\");\n    return this;\n  }\n\n  fps(value) {\n    return this.param(value, \"fps\", \"fps\", fps => {\n      if (isString(fps)) {\n        return fps;\n      } else if (Array.isArray(fps)) {\n        return fps.join(\"-\");\n      } else {\n        return fps;\n      }\n    });\n  }\n\n  height(value) {\n    return this.param(value, \"height\", \"h\", () => {\n      if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n        return Expression.normalize(value);\n      } else {\n        return null;\n      }\n    });\n  }\n\n  htmlHeight(value) {\n    this.param(value, \"html_height\");\n    return this;\n  }\n\n  htmlWidth(value) {\n    this.param(value, \"html_width\");\n    return this;\n  }\n\n  if() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var i, ifVal, j, ref, trIf, trRest;\n\n    switch (value) {\n      case \"else\":\n        this.chain();\n        return this.param(value, \"if\", \"if\");\n\n      case \"end\":\n        this.chain();\n\n        for (i = j = ref = this.chained.length - 1; j >= 0; i = j += -1) {\n          ifVal = this.chained[i].getValue(\"if\");\n\n          if (ifVal === \"end\") {\n            break;\n          } else if (ifVal != null) {\n            trIf = Transformation.new().if(ifVal);\n            this.chained[i].remove(\"if\");\n            trRest = this.chained[i];\n            this.chained[i] = Transformation.new().transformation([trIf, trRest]);\n\n            if (ifVal !== \"else\") {\n              break;\n            }\n          }\n        }\n\n        return this.param(value, \"if\", \"if\");\n\n      case \"\":\n        return Condition.new().setParent(this);\n\n      default:\n        return this.param(value, \"if\", \"if\", value => {\n          return Condition.new(value).toString();\n        });\n    }\n  }\n\n  keyframeInterval(value) {\n    this.param(value, \"keyframe_interval\", \"ki\");\n    return this;\n  }\n\n  ocr(value) {\n    this.param(value, \"ocr\", \"ocr\");\n    return this;\n  }\n\n  offset(value) {\n    var end_o, start_o;\n    [start_o, end_o] = isFunction(value != null ? value.split : void 0) ? value.split('..') : Array.isArray(value) ? value : [null, null];\n\n    if (start_o != null) {\n      this.startOffset(start_o);\n    }\n\n    if (end_o != null) {\n      return this.endOffset(end_o);\n    }\n  }\n\n  opacity(value) {\n    this.param(value, \"opacity\", \"o\", Expression.normalize);\n    return this;\n  }\n\n  overlay(value) {\n    this.layerParam(value, \"overlay\", \"l\");\n    return this;\n  }\n\n  page(value) {\n    this.param(value, \"page\", \"pg\");\n    return this;\n  }\n\n  poster(value) {\n    this.param(value, \"poster\");\n    return this;\n  }\n\n  prefix(value) {\n    this.param(value, \"prefix\", \"p\");\n    return this;\n  }\n\n  quality(value) {\n    this.param(value, \"quality\", \"q\", Expression.normalize);\n    return this;\n  }\n\n  radius(value) {\n    this.arrayParam(value, \"radius\", \"r\", \":\", Expression.normalize);\n    return this;\n  }\n\n  rawTransformation(value) {\n    this.rawParam(value, \"raw_transformation\");\n    return this;\n  }\n\n  size(value) {\n    let height, width;\n\n    if (isFunction(value != null ? value.split : void 0)) {\n      [width, height] = value.split('x');\n      this.width(width);\n      return this.height(height);\n    }\n  }\n\n  sourceTypes(value) {\n    this.param(value, \"source_types\");\n    return this;\n  }\n\n  sourceTransformation(value) {\n    return this.param(value, \"source_transformation\");\n  }\n\n  startOffset(value) {\n    this.rangeParam(value, \"start_offset\", \"so\");\n    return this;\n  }\n\n  streamingProfile(value) {\n    this.param(value, \"streaming_profile\", \"sp\");\n    return this;\n  }\n\n  transformation(value) {\n    this.transformationParam(value, \"transformation\", \"t\");\n    return this;\n  }\n\n  underlay(value) {\n    this.layerParam(value, \"underlay\", \"u\");\n    return this;\n  }\n\n  variable(name, value) {\n    this.param(value, name, name);\n    return this;\n  }\n\n  variables(values) {\n    this.arrayParam(values, \"variables\");\n    return this;\n  }\n\n  videoCodec(value) {\n    this.param(value, \"video_codec\", \"vc\", Param.process_video_params);\n    return this;\n  }\n\n  videoSampling(value) {\n    this.param(value, \"video_sampling\", \"vs\");\n    return this;\n  }\n\n  width(value) {\n    this.param(value, \"width\", \"w\", () => {\n      if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n        return Expression.normalize(value);\n      } else {\n        return null;\n      }\n    });\n    return this;\n  }\n\n  x(value) {\n    this.param(value, \"x\", \"x\", Expression.normalize);\n    return this;\n  }\n\n  y(value) {\n    this.param(value, \"y\", \"y\", Expression.normalize);\n    return this;\n  }\n\n  zoom(value) {\n    this.param(value, \"zoom\", \"z\", Expression.normalize);\n    return this;\n  }\n\n}\n/**\r\n * Transformation Class methods.\r\n * This is a list of the parameters defined in Transformation.\r\n * Values are camelCased.\r\n */\n\n\nconst methods = [\"angle\", \"audioCodec\", \"audioFrequency\", \"aspectRatio\", \"background\", \"bitRate\", \"border\", \"color\", \"colorSpace\", \"crop\", \"customFunction\", \"customPreFunction\", \"defaultImage\", \"delay\", \"density\", \"duration\", \"dpr\", \"effect\", \"else\", \"endIf\", \"endOffset\", \"fallbackContent\", \"fetchFormat\", \"format\", \"flags\", \"gravity\", \"fps\", \"height\", \"htmlHeight\", \"htmlWidth\", \"if\", \"keyframeInterval\", \"ocr\", \"offset\", \"opacity\", \"overlay\", \"page\", \"poster\", \"prefix\", \"quality\", \"radius\", \"rawTransformation\", \"size\", \"sourceTypes\", \"sourceTransformation\", \"startOffset\", \"streamingProfile\", \"transformation\", \"underlay\", \"variable\", \"variables\", \"videoCodec\", \"videoSampling\", \"width\", \"x\", \"y\", \"zoom\"];\n/**\r\n * Parameters that are filtered out before passing the options to an HTML tag.\r\n *\r\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\r\n */\n\nconst PARAM_NAMES = methods.map(snakeCase).concat(CONFIG_PARAMS);\nexport default Transformation;","map":{"version":3,"sources":["C:/Users/Pham Tan Duong/Desktop/cloneGit/fashion/node_modules/@cloudinary/url-gen/backwards/transformation.js"],"names":["Condition","CONFIG_PARAMS","cloneDeep","camelCase","contains","difference","snakeCase","Expression","Layer","TextLayer","SubtitlesLayer","FetchLayer","isObject","isString","isEmpty","isFunction","identity","withCamelCaseKeys","URL_KEYS","assignNotNull","target","sources","forEach","source","Object","keys","key","allStrings","list","length","every","Param","constructor","name","shortName","process","set","origValue","serialize","val","valid","value","Array","isArray","norm_color","replace","build_array","arg","process_video_params","param","video","codec","profile","level","String","ArrayParam","sep","undefined","arrayValue","flat","map","t","join","v","TransformationParam","result","joined","Transformation","filter","origValue1","number_pattern","offset_any_pattern","RangeParam","norm_range_value","offset","match","RegExp","modifier","RawParam","LayerParam","layerOptions","resourceType","text","url","test","substr","toString","textStyle","layer","textStyleIdentifier","TransformationBase","options","parent","trans","toOptions","withChain","opt","otherOptions","chained","tr","push","transformation","setParent","object","fromOptions","getParent","abbr","defaultValue","rawParam","lastArgCallback","arguments","rangeParam","arrayParam","transformationParam","layerParam","getValue","get","remove","temp","results","VAR_NAME_RE","sort","toPlainObject","hash","chain","names","getOwnPropertyNames","resetTransformations","fromTransformation","other","camelKey","values","methods","apply","hasLayer","ifParam","j","len","paramList","ref","ref1","ref2","ref3","ref4","resultArray","transformationList","transformationString","transformations","variables","vars","processVar","normalize","concat","k","len1","unshift","x","param_separator","trans_separator","listNames","toHtmlAttributes","attrName","height","width","snakeCaseKey","PARAM_NAMES","slice","parseFloat","isValidParamName","indexOf","toHtml","clone","args","callback","varArray","processCustomFunction","function_type","btoa","new","angle","audioCodec","audioFrequency","aspectRatio","background","bitRate","border","assign","color","colorSpace","crop","customFunction","customPreFunction","defaultImage","delay","density","duration","dpr","effect","else","if","endIf","endOffset","fallbackContent","fetchFormat","format","flags","gravity","fps","htmlHeight","htmlWidth","i","ifVal","trIf","trRest","keyframeInterval","ocr","end_o","start_o","split","startOffset","opacity","overlay","page","poster","prefix","quality","radius","rawTransformation","size","sourceTypes","sourceTransformation","streamingProfile","underlay","variable","videoCodec","videoSampling","y","zoom"],"mappings":"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","sourcesContent":["import Condition from './condition.js';\r\nimport { CONFIG_PARAMS } from './configuration.js';\r\nimport { cloneDeep } from '../internal/utils/cloneDeep.js';\r\nimport { camelCase, contains, difference, } from \"./utils/legacyBaseUtil.js\";\r\nimport { snakeCase } from \"./utils/snakeCase.js\";\r\nimport Expression from './expression.js';\r\nimport Layer from './legacyLayer/layer.js';\r\nimport TextLayer from './legacyLayer/textlayer.js';\r\nimport SubtitlesLayer from './legacyLayer/subtitleslayer.js';\r\nimport FetchLayer from './legacyLayer/fetchlayer.js';\r\nimport { isObject } from \"./utils/isObject.js\";\r\nimport { isString } from \"../internal/utils/dataStructureUtils.js\";\r\nimport { isEmpty } from \"./utils/isEmpty.js\";\r\nimport { isFunction } from \"./utils/isFunction.js\";\r\nimport { identity, withCamelCaseKeys } from \"./utils/legacyBaseUtil.js\";\r\n/**\r\n * A list of keys used by the url() function.\r\n * @private\r\n */\r\nexport const URL_KEYS = [\r\n    'accessibility',\r\n    'api_secret',\r\n    'auth_token',\r\n    'cdn_subdomain',\r\n    'cloud_name',\r\n    'cname',\r\n    'format',\r\n    'placeholder',\r\n    'private_cdn',\r\n    'resource_type',\r\n    'secure',\r\n    'secure_cdn_subdomain',\r\n    'secure_distribution',\r\n    'shorten',\r\n    'sign_url',\r\n    'signature',\r\n    'ssl_detected',\r\n    'type',\r\n    'url_suffix',\r\n    'use_root_path',\r\n    'version'\r\n];\r\n/**\r\n * Assign key, value to target, when value is not null.<br>\r\n *   This function mutates the target!\r\n * @param {object} target the object to assign the values to\r\n * @param {object} sources one or more objects to get values from\r\n * @returns {object} the target after the assignment\r\n */\r\nfunction assignNotNull(target, ...sources) {\r\n    sources.forEach(source => {\r\n        Object.keys(source).forEach(key => {\r\n            // @ts-ignore\r\n            if (source[key] != null) {\r\n                // @ts-ignore\r\n                target[key] = source[key];\r\n            }\r\n        });\r\n    });\r\n    return target;\r\n}\r\n/**\r\n * Return true if all items in list are strings\r\n * @function Util.allString\r\n * @param {Array} list - an array of items\r\n */\r\nconst allStrings = function (list) {\r\n    return list.length && list.every(isString);\r\n};\r\n/**\r\n * Transformation parameters\r\n * Depends on 'util', 'transformation'\r\n */\r\nclass Param {\r\n    /**\r\n     * Represents a single parameter.\r\n     * @class Param\r\n     * @param {string} name - The name of the parameter in snake_case\r\n     * @param {string} shortName - The name of the serialized form of the parameter.\r\n     *                         If a value is not provided, the parameter will not be serialized.\r\n     * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\r\n     * @ignore\r\n     */\r\n    constructor(name, shortName, process = identity) {\r\n        /**\r\n         * The name of the parameter in snake_case\r\n         * @member {string} Param#name\r\n         */\r\n        this.name = name;\r\n        /**\r\n         * The name of the serialized form of the parameter\r\n         * @member {string} Param#shortName\r\n         */\r\n        this.shortName = shortName;\r\n        /**\r\n         * Manipulate origValue when value is called\r\n         * @member {function} Param#process\r\n         */\r\n        this.process = process;\r\n    }\r\n    /**\r\n     * Set a (unprocessed) value for this parameter\r\n     * @function Param#set\r\n     * @param {*} origValue - the value of the parameter\r\n     * @return {Param} self for chaining\r\n     */\r\n    set(origValue) {\r\n        this.origValue = origValue;\r\n        return this;\r\n    }\r\n    /**\r\n     * Generate the serialized form of the parameter\r\n     * @function Param#serialize\r\n     * @return {string} the serialized form of the parameter\r\n     */\r\n    serialize() {\r\n        var val, valid;\r\n        val = this.value();\r\n        valid = Array.isArray(val) || isObject(val) || isString(val) ? !isEmpty(val) : val != null;\r\n        if ((this.shortName != null) && valid) {\r\n            return `${this.shortName}_${val}`;\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    /**\r\n     * Return the processed value of the parameter\r\n     * @function Param#value\r\n     */\r\n    value() {\r\n        return this.process(this.origValue);\r\n    }\r\n    static norm_color(value) {\r\n        return value != null ? value.replace(/^#/, 'rgb:') : void 0;\r\n    }\r\n    static build_array(arg) {\r\n        if (arg == null) {\r\n            return [];\r\n        }\r\n        else if (Array.isArray(arg)) {\r\n            return arg;\r\n        }\r\n        else {\r\n            return [arg];\r\n        }\r\n    }\r\n    /**\r\n     * Covert value to video codec string.\r\n     *\r\n     * If the parameter is an object,\r\n     * @param {(string|Object)} param - the video codec as either a String or a Hash\r\n     * @return {string} the video codec string in the format codec:profile:level\r\n     * @example\r\n     * vc_[ :profile : [level]]\r\n     * or\r\n     { codec: 'h264', profile: 'basic', level: '3.1' }\r\n     * @ignore\r\n     */\r\n    static process_video_params(param) {\r\n        var video;\r\n        switch (param.constructor) {\r\n            case Object:\r\n                video = \"\";\r\n                if ('codec' in param) {\r\n                    video = param.codec;\r\n                    if ('profile' in param) {\r\n                        video += \":\" + param.profile;\r\n                        if ('level' in param) {\r\n                            video += \":\" + param.level;\r\n                        }\r\n                    }\r\n                }\r\n                return video;\r\n            case String:\r\n                return param;\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n}\r\nclass ArrayParam extends Param {\r\n    /**\r\n     * A parameter that represents an array.\r\n     * @param {string} name - The name of the parameter in snake_case.\r\n     * @param {string} shortName - The name of the serialized form of the parameter\r\n     *                         If a value is not provided, the parameter will not be serialized.\r\n     * @param {string} [sep='.'] - The separator to use when joining the array elements together\r\n     * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\r\n     * @class ArrayParam\r\n     * @extends Param\r\n     * @ignore\r\n     */\r\n    constructor(name, shortName, sep = '.', process = undefined) {\r\n        super(name, shortName, process);\r\n        this.sep = sep;\r\n    }\r\n    serialize() {\r\n        if (this.shortName != null) {\r\n            let arrayValue = this.value();\r\n            if (isEmpty(arrayValue)) {\r\n                return '';\r\n            }\r\n            else if (isString(arrayValue)) {\r\n                return `${this.shortName}_${arrayValue}`;\r\n            }\r\n            else {\r\n                let flat = arrayValue.map((t) => isFunction(t.serialize) ? t.serialize() : t).join(this.sep);\r\n                return `${this.shortName}_${flat}`;\r\n            }\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    value() {\r\n        if (Array.isArray(this.origValue)) {\r\n            return this.origValue.map(v => this.process(v));\r\n        }\r\n        else {\r\n            return this.process(this.origValue);\r\n        }\r\n    }\r\n    set(origValue) {\r\n        if ((origValue == null) || Array.isArray(origValue)) {\r\n            return super.set(origValue);\r\n        }\r\n        else {\r\n            return super.set([origValue]);\r\n        }\r\n    }\r\n}\r\nclass TransformationParam extends Param {\r\n    /**\r\n     * A parameter that represents a transformation\r\n     * @param {string} name - The name of the parameter in snake_case\r\n     * @param {string} [shortName='t'] - The name of the serialized form of the parameter\r\n     * @param {string} [sep='.'] - The separator to use when joining the array elements together\r\n     * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\r\n     * @class TransformationParam\r\n     * @extends Param\r\n     * @ignore\r\n     */\r\n    constructor(name, shortName = \"t\", sep = '.', process = undefined) {\r\n        super(name, shortName, process);\r\n        this.sep = sep;\r\n    }\r\n    /**\r\n     * Generate string representations of the transformation.\r\n     * @returns {*} Returns either the transformation as a string, or an array of string representations.\r\n     */\r\n    serialize() {\r\n        let result = '';\r\n        const val = this.value();\r\n        if (isEmpty(val)) {\r\n            return result;\r\n        }\r\n        // val is an array of strings so join them\r\n        if (allStrings(val)) {\r\n            const joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\r\n            if (!isEmpty(joined)) {\r\n                // in case options.transformation was not set with an empty string (val != ['']);\r\n                result = `${this.shortName}_${joined}`;\r\n            }\r\n        }\r\n        else { // Convert val to an array of strings\r\n            result = val.map((t) => {\r\n                if (isString(t) && !isEmpty(t)) {\r\n                    return `${this.shortName}_${t}`;\r\n                }\r\n                if (isFunction(t.serialize)) {\r\n                    return t.serialize();\r\n                }\r\n                if (isObject(t) && !isEmpty(t)) {\r\n                    return new Transformation(t).serialize();\r\n                }\r\n                return undefined;\r\n            }).filter((t) => t);\r\n        }\r\n        return result;\r\n    }\r\n    set(origValue1) {\r\n        this.origValue = origValue1;\r\n        if (Array.isArray(this.origValue)) {\r\n            return super.set(this.origValue);\r\n        }\r\n        else {\r\n            return super.set([this.origValue]);\r\n        }\r\n    }\r\n}\r\nconst number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\r\nconst offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\r\nclass RangeParam extends Param {\r\n    /**\r\n     * A parameter that represents a range\r\n     * @param {string} name - The name of the parameter in snake_case\r\n     * @param {string} shortName - The name of the serialized form of the parameter\r\n     *                         If a value is not provided, the parameter will not be serialized.\r\n     * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\r\n     * @class RangeParam\r\n     * @extends Param\r\n     * @ignore\r\n     */\r\n    constructor(name, shortName, process = RangeParam.norm_range_value) {\r\n        super(name, shortName, process);\r\n    }\r\n    static norm_range_value(value) {\r\n        let offset = String(value).match(new RegExp('^' + offset_any_pattern + '$'));\r\n        if (offset) {\r\n            let modifier = offset[5] != null ? 'p' : '';\r\n            value = (offset[1] || offset[4]) + modifier;\r\n        }\r\n        return value;\r\n    }\r\n}\r\nclass RawParam extends Param {\r\n    constructor(name, shortName, process = identity) {\r\n        super(name, shortName, process);\r\n    }\r\n    serialize() {\r\n        return this.value();\r\n    }\r\n}\r\nclass LayerParam extends Param {\r\n    // Parse layer options\r\n    // @return [string] layer transformation string\r\n    // @private\r\n    value() {\r\n        if (this.origValue == null) {\r\n            return '';\r\n        }\r\n        let result;\r\n        if (this.origValue instanceof Layer) {\r\n            result = this.origValue;\r\n        }\r\n        else if (isObject(this.origValue)) {\r\n            let layerOptions = withCamelCaseKeys(this.origValue);\r\n            // @ts-ignore\r\n            if (layerOptions.resourceType === \"text\" || (layerOptions.text != null)) {\r\n                result = new TextLayer(layerOptions);\r\n            }\r\n            else { // @ts-ignore\r\n                if (layerOptions.resourceType === \"subtitles\") {\r\n                    result = new SubtitlesLayer(layerOptions);\r\n                }\r\n                else { // @ts-ignore\r\n                    if (layerOptions.resourceType === \"fetch\" || (layerOptions.url != null)) {\r\n                        result = new FetchLayer(layerOptions);\r\n                    }\r\n                    else {\r\n                        result = new Layer(layerOptions);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (isString(this.origValue)) {\r\n            if (/^fetch:.+/.test(this.origValue)) {\r\n                result = new FetchLayer(this.origValue.substr(6));\r\n            }\r\n            else {\r\n                result = this.origValue;\r\n            }\r\n        }\r\n        else {\r\n            result = '';\r\n        }\r\n        return result.toString();\r\n    }\r\n    static textStyle(layer) {\r\n        return (new TextLayer(layer)).textStyleIdentifier();\r\n    }\r\n}\r\n/**\r\n * TransformationBase\r\n * Depends on 'configuration', 'parameters','util'\r\n * @internal\r\n */\r\nclass TransformationBase {\r\n    /**\r\n     * The base class for transformations.\r\n     * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\r\n     * @class TransformationBase\r\n     */\r\n    constructor(options) {\r\n        /** @private */\r\n        /** @private */\r\n        let parent;\r\n        let trans;\r\n        parent = void 0;\r\n        trans = {};\r\n        /**\r\n         * Return an options object that can be used to create an identical Transformation\r\n         * @function Transformation#toOptions\r\n         * @return {Object} Returns a plain object representing this transformation\r\n         */\r\n        this.toOptions = (withChain) => {\r\n            let opt = {};\r\n            if (withChain == null) {\r\n                withChain = true;\r\n            }\r\n            // @ts-ignore\r\n            Object.keys(trans).forEach(key => opt[key] = trans[key].origValue);\r\n            assignNotNull(opt, this.otherOptions);\r\n            if (withChain && !isEmpty(this.chained)) {\r\n                let list = this.chained.map((tr) => tr.toOptions());\r\n                list.push(opt);\r\n                opt = {};\r\n                assignNotNull(opt, this.otherOptions);\r\n                // @ts-ignore\r\n                opt.transformation = list;\r\n            }\r\n            return opt;\r\n        };\r\n        /**\r\n         * Set a parent for this object for chaining purposes.\r\n         *\r\n         * @function Transformation#setParent\r\n         * @param {Object} object - the parent to be assigned to\r\n         * @returns {Transformation} Returns this instance for chaining purposes.\r\n         */\r\n        this.setParent = (object) => {\r\n            parent = object;\r\n            if (object != null) {\r\n                // @ts-ignore\r\n                this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * Returns the parent of this object in the chain\r\n         * @function Transformation#getParent\r\n         * @protected\r\n         * @return {Object} Returns the parent of this object if there is any\r\n         */\r\n        this.getParent = () => {\r\n            return parent;\r\n        };\r\n        // Helper methods to create parameter methods\r\n        // These methods are defined here because they access `trans` which is\r\n        // a private member of `TransformationBase`\r\n        /** @protected */\r\n        this.param = (value, name, abbr, defaultValue, process) => {\r\n            if (process == null) {\r\n                if (isFunction(defaultValue)) {\r\n                    process = defaultValue;\r\n                }\r\n                else {\r\n                    process = identity;\r\n                }\r\n            }\r\n            // @ts-ignore\r\n            trans[name] = new Param(name, abbr, process).set(value);\r\n            return this;\r\n        };\r\n        /** @protected */\r\n        this.rawParam = function (value, name, abbr, defaultValue, process) {\r\n            process = lastArgCallback(arguments);\r\n            // @ts-ignore\r\n            trans[name] = new RawParam(name, abbr, process).set(value);\r\n            return this;\r\n        };\r\n        /** @protected */\r\n        this.rangeParam = function (value, name, abbr, defaultValue, process) {\r\n            process = lastArgCallback(arguments);\r\n            // @ts-ignore\r\n            trans[name] = new RangeParam(name, abbr, process).set(value);\r\n            return this;\r\n        };\r\n        /** @protected */\r\n        this.arrayParam = function (value, name, abbr, sep = \":\", defaultValue = [], process = undefined) {\r\n            process = lastArgCallback(arguments);\r\n            // @ts-ignore\r\n            trans[name] = new ArrayParam(name, abbr, sep, process).set(value);\r\n            return this;\r\n        };\r\n        /** @protected */\r\n        this.transformationParam = function (value, name, abbr, sep = \".\", defaultValue = undefined, process = undefined) {\r\n            process = lastArgCallback(arguments);\r\n            // @ts-ignore\r\n            trans[name] = new TransformationParam(name, abbr, sep, process).set(value);\r\n            return this;\r\n        };\r\n        this.layerParam = function (value, name, abbr) {\r\n            // @ts-ignore\r\n            trans[name] = new LayerParam(name, abbr).set(value);\r\n            return this;\r\n        };\r\n        // End Helper methods\r\n        /**\r\n         * Get the value associated with the given name.\r\n         * Get the value associated with the given name.\r\n         * @function Transformation#getValue\r\n         * @param {string} name - the name of the parameter\r\n         * @return {*} the processed value associated with the given name\r\n         * @description Use {@link get}.origValue for the value originally provided for the parameter\r\n         */\r\n        this.getValue = function (name) {\r\n            // @ts-ignore\r\n            let value = trans[name] && trans[name].value();\r\n            return value != null ? value : this.otherOptions[name];\r\n        };\r\n        /**\r\n         * Get the parameter object for the given parameter name\r\n         * @function Transformation#get\r\n         * @param {string} name the name of the transformation parameter\r\n         * @returns {Param} the param object for the given name, or undefined\r\n         */\r\n        this.get = function (name) {\r\n            // @ts-ignore\r\n            return trans[name];\r\n        };\r\n        /**\r\n         * Remove a transformation option from the transformation.\r\n         * @function Transformation#remove\r\n         * @param {string} name - the name of the option to remove\r\n         * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\r\n         *              returned value depends on the value.\r\n         */\r\n        this.remove = function (name) {\r\n            var temp;\r\n            switch (false) {\r\n                // @ts-ignore\r\n                case trans[name] == null:\r\n                    // @ts-ignore\r\n                    temp = trans[name];\r\n                    // @ts-ignore\r\n                    delete trans[name];\r\n                    return temp.origValue;\r\n                case this.otherOptions[name] == null:\r\n                    temp = this.otherOptions[name];\r\n                    delete this.otherOptions[name];\r\n                    return temp;\r\n                default:\r\n                    return null;\r\n            }\r\n        };\r\n        /**\r\n         * Return an array of all the keys (option names) in the transformation.\r\n         * @return {Array<string>} the keys in snakeCase format\r\n         */\r\n        this.keys = function () {\r\n            var key;\r\n            return ((function () {\r\n                var results;\r\n                results = [];\r\n                for (key in trans) {\r\n                    if (key != null) {\r\n                        results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\r\n                    }\r\n                }\r\n                return results;\r\n            })()).sort();\r\n        };\r\n        /**\r\n         * Returns a plain object representation of the transformation. Values are processed.\r\n         * @function Transformation#toPlainObject\r\n         * @return {Object} the transformation options as plain object\r\n         */\r\n        this.toPlainObject = function () {\r\n            var hash, key, list;\r\n            hash = {};\r\n            for (key in trans) {\r\n                // @ts-ignore\r\n                hash[key] = trans[key].value();\r\n                // @ts-ignore\r\n                if (isObject(hash[key])) {\r\n                    // @ts-ignore\r\n                    hash[key] = cloneDeep(hash[key]);\r\n                }\r\n            }\r\n            if (!isEmpty(this.chained)) {\r\n                list = this.chained.map((tr) => tr.toPlainObject());\r\n                list.push(hash);\r\n                hash = {\r\n                    transformation: list\r\n                };\r\n            }\r\n            return hash;\r\n        };\r\n        /**\r\n         * Complete the current transformation and chain to a new one.\r\n         * In the URL, transformations are chained together by slashes.\r\n         * @function Transformation#chain\r\n         * @return {Transformation} Returns this transformation for chaining\r\n         * @example\r\n         * var tr = cloudinary.Transformation.new();\r\n         * tr.width(10).crop('fit').chain().angle(15).serialize()\r\n         * // produces \"c_fit,w_10/a_15\"\r\n         */\r\n        this.chain = function () {\r\n            var names, tr;\r\n            names = Object.getOwnPropertyNames(trans);\r\n            if (names.length !== 0) {\r\n                tr = new this.constructor(this.toOptions(false));\r\n                this.resetTransformations();\r\n                this.chained.push(tr);\r\n            }\r\n            return this;\r\n        };\r\n        this.resetTransformations = function () {\r\n            trans = {};\r\n            return this;\r\n        };\r\n        this.otherOptions = {};\r\n        this.chained = [];\r\n        this.fromOptions(options);\r\n    }\r\n    /**\r\n     * Merge the provided options with own's options\r\n     * @param {Object} [options={}] key-value list of options\r\n     * @returns {Transformation} Returns this instance for chaining\r\n     */\r\n    fromOptions(options = {}) {\r\n        if (options instanceof TransformationBase) {\r\n            this.fromTransformation(options);\r\n        }\r\n        else {\r\n            if (isString(options) || Array.isArray(options)) {\r\n                options = {\r\n                    transformation: options\r\n                };\r\n            }\r\n            options = cloneDeep(options);\r\n            // Handling of \"if\" statements precedes other options as it creates a chained transformation\r\n            // @ts-ignore\r\n            if (options[\"if\"]) {\r\n                // @ts-ignore\r\n                this.set(\"if\", options[\"if\"]);\r\n                // @ts-ignore\r\n                delete options[\"if\"];\r\n            }\r\n            for (let key in options) {\r\n                // @ts-ignore\r\n                let opt = options[key];\r\n                if (opt != null) {\r\n                    if (key.match(VAR_NAME_RE)) {\r\n                        if (key !== '$attr') {\r\n                            this.set('variable', key, opt);\r\n                        }\r\n                    }\r\n                    else {\r\n                        this.set(key, opt);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    fromTransformation(other) {\r\n        if (other instanceof TransformationBase) {\r\n            other.keys().forEach(key => this.set(key, other.get(key).origValue));\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Set a parameter.\r\n     * The parameter name `key` is converted to\r\n     * @param {string} key - the name of the parameter\r\n     * @param {*} values - the value of the parameter\r\n     * @returns {Transformation} Returns this instance for chaining\r\n     */\r\n    set(key, ...values) {\r\n        let camelKey;\r\n        camelKey = camelCase(key);\r\n        if (contains(methods, camelKey)) {\r\n            // @ts-ignore\r\n            this[camelKey].apply(this, values);\r\n        }\r\n        else {\r\n            this.otherOptions[key] = values[0];\r\n        }\r\n        return this;\r\n    }\r\n    hasLayer() {\r\n        return this.getValue(\"overlay\") || this.getValue(\"underlay\");\r\n    }\r\n    /**\r\n     * Generate a string representation of the transformation.\r\n     * @function Transformation#serialize\r\n     * @return {string} Returns the transformation as a string\r\n     */\r\n    serialize() {\r\n        var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\r\n        resultArray = this.chained.map((tr) => tr.serialize());\r\n        paramList = this.keys();\r\n        transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\r\n        ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\r\n        variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\r\n        paramList = difference(paramList, [\"transformation\", \"if\", \"variables\"]);\r\n        vars = [];\r\n        transformationList = [];\r\n        for (j = 0, len = paramList.length; j < len; j++) {\r\n            t = paramList[j];\r\n            if (t.match(VAR_NAME_RE)) {\r\n                vars.push(t + \"_\" + Expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\r\n            }\r\n            else {\r\n                transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\r\n            }\r\n        }\r\n        switch (false) {\r\n            case !isString(transformations):\r\n                transformationList.push(transformations);\r\n                break;\r\n            case !Array.isArray(transformations):\r\n                resultArray = resultArray.concat(transformations);\r\n        }\r\n        transformationList = (function () {\r\n            var k, len1, results;\r\n            results = [];\r\n            for (k = 0, len1 = transformationList.length; k < len1; k++) {\r\n                value = transformationList[k];\r\n                if (Array.isArray(value) && !isEmpty(value) || !Array.isArray(value) && value) {\r\n                    results.push(value);\r\n                }\r\n            }\r\n            return results;\r\n        })();\r\n        transformationList = vars.sort().concat(variables).concat(transformationList.sort());\r\n        if (ifParam === \"if_end\") {\r\n            transformationList.push(ifParam);\r\n        }\r\n        else if (!isEmpty(ifParam)) {\r\n            transformationList.unshift(ifParam);\r\n        }\r\n        transformationString = (transformationList).filter(x => !!x).join(param_separator);\r\n        if (!isEmpty(transformationString)) {\r\n            resultArray.push(transformationString);\r\n        }\r\n        return (resultArray).filter((x) => !!x).join(trans_separator);\r\n    }\r\n    /**\r\n     * Provide a list of all the valid transformation option names\r\n     * @function Transformation#listNames\r\n     * @private\r\n     * @return {Array<string>} a array of all the valid option names\r\n     */\r\n    static listNames() {\r\n        return methods;\r\n    }\r\n    /**\r\n     * Returns the attributes for an HTML tag.\r\n     * @function Cloudinary.toHtmlAttributes\r\n     * @return PlainObject\r\n     */\r\n    toHtmlAttributes() {\r\n        let attrName, height, options, ref2, ref3, value, width;\r\n        options = {};\r\n        let snakeCaseKey;\r\n        Object.keys(this.otherOptions).forEach(key => {\r\n            value = this.otherOptions[key];\r\n            snakeCaseKey = snakeCase(key);\r\n            if (!contains(PARAM_NAMES, snakeCaseKey) && !contains(URL_KEYS, snakeCaseKey)) {\r\n                attrName = /^html_/.test(key) ? key.slice(5) : key;\r\n                options[attrName] = value;\r\n            }\r\n        });\r\n        // convert all \"html_key\" to \"key\" with the same value\r\n        this.keys().forEach(key => {\r\n            if (/^html_/.test(key)) {\r\n                options[camelCase(key.slice(5))] = this.getValue(key);\r\n            }\r\n        });\r\n        if (!(this.hasLayer() || this.getValue(\"angle\") || contains([\"fit\", \"limit\", \"lfill\"], this.getValue(\"crop\")))) {\r\n            width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\r\n            height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\r\n            if (parseFloat(width) >= 1.0) {\r\n                if (options.width == null) {\r\n                    options.width = width;\r\n                }\r\n            }\r\n            if (parseFloat(height) >= 1.0) {\r\n                if (options.height == null) {\r\n                    options.height = height;\r\n                }\r\n            }\r\n        }\r\n        return options;\r\n    }\r\n    static isValidParamName(name) {\r\n        return methods.indexOf(camelCase(name)) >= 0;\r\n    }\r\n    /**\r\n     * Delegate to the parent (up the call chain) to produce HTML\r\n     * @function Transformation#toHtml\r\n     * @return {string} HTML representation of the parent if possible.\r\n     * @example\r\n     * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\r\n     * // ImageTag {name: \"img\", publicId: \"sample\"}\r\n     * tag.toHtml()\r\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\r\n     * tag.transformation().crop(\"fit\").width(300).toHtml()\r\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\r\n     */\r\n    toHtml() {\r\n        var ref;\r\n        return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\r\n    }\r\n    toString() {\r\n        return this.serialize();\r\n    }\r\n    clone() {\r\n        return new TransformationBase(this.toOptions(true));\r\n    }\r\n}\r\nconst VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\r\nconst trans_separator = '/';\r\nconst param_separator = ',';\r\nfunction lastArgCallback(args) {\r\n    var callback;\r\n    callback = args != null ? args[args.length - 1] : void 0;\r\n    if (isFunction(callback)) {\r\n        return callback;\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\nfunction processVar(varArray) {\r\n    var j, len, name, results, v;\r\n    if (Array.isArray(varArray)) {\r\n        results = [];\r\n        for (j = 0, len = varArray.length; j < len; j++) {\r\n            [name, v] = varArray[j];\r\n            results.push(`${name}_${Expression.normalize(v)}`);\r\n        }\r\n        return results;\r\n    }\r\n    else {\r\n        return varArray;\r\n    }\r\n}\r\n// @ts-ignore\r\nfunction processCustomFunction({ function_type, source }) {\r\n    if (function_type === 'remote') {\r\n        return [function_type, btoa(source)].join(\":\");\r\n    }\r\n    else if (function_type === 'wasm') {\r\n        return [function_type, source].join(\":\");\r\n    }\r\n}\r\n/**\r\n * Transformation Class methods.\r\n * This is a list of the parameters defined in Transformation.\r\n * Values are camelCased.\r\n * @const Transformation.methods\r\n * @private\r\n * @ignore\r\n * @type {Array<string>}\r\n */\r\n/**\r\n * Parameters that are filtered out before passing the options to an HTML tag.\r\n *\r\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\r\n * @const {Array<string>} Transformation.PARAM_NAMES\r\n * @private\r\n * @ignore\r\n * @see toHtmlAttributes\r\n */\r\nclass Transformation extends TransformationBase {\r\n    /**\r\n     * Represents a single transformation.\r\n     * @class Transformation\r\n     * @example\r\n     * t = new cloudinary.Transformation();\r\n     * t.angle(20).crop(\"scale\").width(\"auto\");\r\n     *\r\n     * // or\r\n     *\r\n     * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\r\n     * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\r\n     *  target=\"_blank\">Available image transformations</a>\r\n     * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\r\n     *  target=\"_blank\">Available video transformations</a>\r\n     */\r\n    constructor(options) {\r\n        super(options);\r\n    }\r\n    /**\r\n     * Convenience constructor\r\n     * @param {Object} options\r\n     * @return {Transformation}\r\n     * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\r\n     */\r\n    static new(options) {\r\n        return new Transformation(options);\r\n    }\r\n    /*\r\n      Transformation Parameters\r\n    */\r\n    angle(value) {\r\n        this.arrayParam(value, \"angle\", \"a\", \".\", Expression.normalize);\r\n        return this;\r\n    }\r\n    audioCodec(value) {\r\n        this.param(value, \"audio_codec\", \"ac\");\r\n        return this;\r\n    }\r\n    audioFrequency(value) {\r\n        this.param(value, \"audio_frequency\", \"af\");\r\n        return this;\r\n    }\r\n    aspectRatio(value) {\r\n        this.param(value, \"aspect_ratio\", \"ar\", Expression.normalize);\r\n        return this;\r\n    }\r\n    background(value) {\r\n        this.param(value, \"background\", \"b\", Param.norm_color);\r\n        return this;\r\n    }\r\n    bitRate(value) {\r\n        this.param(value, \"bit_rate\", \"br\");\r\n        return this;\r\n    }\r\n    border(value) {\r\n        return this.param(value, \"border\", \"bo\", (border) => {\r\n            if (isObject(border)) {\r\n                border = Object.assign({}, {\r\n                    color: \"black\",\r\n                    width: 2\r\n                }, border);\r\n                return `${border.width}px_solid_${Param.norm_color(border.color)}`;\r\n            }\r\n            else {\r\n                return border;\r\n            }\r\n        });\r\n    }\r\n    color(value) {\r\n        this.param(value, \"color\", \"co\", Param.norm_color);\r\n        return this;\r\n    }\r\n    colorSpace(value) {\r\n        this.param(value, \"color_space\", \"cs\");\r\n        return this;\r\n    }\r\n    crop(value) {\r\n        this.param(value, \"crop\", \"c\");\r\n        return this;\r\n    }\r\n    customFunction(value) {\r\n        return this.param(value, \"custom_function\", \"fn\", () => {\r\n            return processCustomFunction(value);\r\n        });\r\n    }\r\n    customPreFunction(value) {\r\n        if (this.get('custom_function')) {\r\n            return;\r\n        }\r\n        return this.rawParam(value, \"custom_function\", \"\", () => {\r\n            value = processCustomFunction(value);\r\n            return value ? `fn_pre:${value}` : value;\r\n        });\r\n    }\r\n    defaultImage(value) {\r\n        this.param(value, \"default_image\", \"d\");\r\n        return this;\r\n    }\r\n    delay(value) {\r\n        this.param(value, \"delay\", \"dl\");\r\n        return this;\r\n    }\r\n    density(value) {\r\n        this.param(value, \"density\", \"dn\");\r\n        return this;\r\n    }\r\n    duration(value) {\r\n        this.rangeParam(value, \"duration\", \"du\");\r\n        return this;\r\n    }\r\n    dpr(value) {\r\n        return this.param(value, \"dpr\", \"dpr\", (dpr) => {\r\n            dpr = dpr.toString();\r\n            if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\r\n                return dpr + \".0\";\r\n            }\r\n            else {\r\n                return Expression.normalize(dpr);\r\n            }\r\n        });\r\n    }\r\n    effect(value) {\r\n        this.arrayParam(value, \"effect\", \"e\", \":\", Expression.normalize);\r\n        return this;\r\n    }\r\n    else() {\r\n        return this.if('else');\r\n    }\r\n    endIf() {\r\n        return this.if('end');\r\n    }\r\n    endOffset(value) {\r\n        this.rangeParam(value, \"end_offset\", \"eo\");\r\n        return this;\r\n    }\r\n    fallbackContent(value) {\r\n        this.param(value, \"fallback_content\");\r\n        return this;\r\n    }\r\n    fetchFormat(value) {\r\n        this.param(value, \"fetch_format\", \"f\");\r\n        return this;\r\n    }\r\n    format(value) {\r\n        this.param(value, \"format\");\r\n        return this;\r\n    }\r\n    flags(value) {\r\n        this.arrayParam(value, \"flags\", \"fl\", \".\");\r\n        return this;\r\n    }\r\n    gravity(value) {\r\n        this.param(value, \"gravity\", \"g\");\r\n        return this;\r\n    }\r\n    fps(value) {\r\n        return this.param(value, \"fps\", \"fps\", (fps) => {\r\n            if (isString(fps)) {\r\n                return fps;\r\n            }\r\n            else if (Array.isArray(fps)) {\r\n                return fps.join(\"-\");\r\n            }\r\n            else {\r\n                return fps;\r\n            }\r\n        });\r\n    }\r\n    height(value) {\r\n        return this.param(value, \"height\", \"h\", () => {\r\n            if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\r\n                return Expression.normalize(value);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        });\r\n    }\r\n    htmlHeight(value) {\r\n        this.param(value, \"html_height\");\r\n        return this;\r\n    }\r\n    htmlWidth(value) {\r\n        this.param(value, \"html_width\");\r\n        return this;\r\n    }\r\n    if(value = \"\") {\r\n        var i, ifVal, j, ref, trIf, trRest;\r\n        switch (value) {\r\n            case \"else\":\r\n                this.chain();\r\n                return this.param(value, \"if\", \"if\");\r\n            case \"end\":\r\n                this.chain();\r\n                for (i = j = ref = this.chained.length - 1; j >= 0; i = j += -1) {\r\n                    ifVal = this.chained[i].getValue(\"if\");\r\n                    if (ifVal === \"end\") {\r\n                        break;\r\n                    }\r\n                    else if (ifVal != null) {\r\n                        trIf = Transformation.new().if(ifVal);\r\n                        this.chained[i].remove(\"if\");\r\n                        trRest = this.chained[i];\r\n                        this.chained[i] = Transformation.new().transformation([trIf, trRest]);\r\n                        if (ifVal !== \"else\") {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                return this.param(value, \"if\", \"if\");\r\n            case \"\":\r\n                return Condition.new().setParent(this);\r\n            default:\r\n                return this.param(value, \"if\", \"if\", (value) => {\r\n                    return Condition.new(value).toString();\r\n                });\r\n        }\r\n    }\r\n    keyframeInterval(value) {\r\n        this.param(value, \"keyframe_interval\", \"ki\");\r\n        return this;\r\n    }\r\n    ocr(value) {\r\n        this.param(value, \"ocr\", \"ocr\");\r\n        return this;\r\n    }\r\n    offset(value) {\r\n        var end_o, start_o;\r\n        [start_o, end_o] = (isFunction(value != null ? value.split : void 0)) ? value.split('..') : Array.isArray(value) ? value : [null, null];\r\n        if (start_o != null) {\r\n            this.startOffset(start_o);\r\n        }\r\n        if (end_o != null) {\r\n            return this.endOffset(end_o);\r\n        }\r\n    }\r\n    opacity(value) {\r\n        this.param(value, \"opacity\", \"o\", Expression.normalize);\r\n        return this;\r\n    }\r\n    overlay(value) {\r\n        this.layerParam(value, \"overlay\", \"l\");\r\n        return this;\r\n    }\r\n    page(value) {\r\n        this.param(value, \"page\", \"pg\");\r\n        return this;\r\n    }\r\n    poster(value) {\r\n        this.param(value, \"poster\");\r\n        return this;\r\n    }\r\n    prefix(value) {\r\n        this.param(value, \"prefix\", \"p\");\r\n        return this;\r\n    }\r\n    quality(value) {\r\n        this.param(value, \"quality\", \"q\", Expression.normalize);\r\n        return this;\r\n    }\r\n    radius(value) {\r\n        this.arrayParam(value, \"radius\", \"r\", \":\", Expression.normalize);\r\n        return this;\r\n    }\r\n    rawTransformation(value) {\r\n        this.rawParam(value, \"raw_transformation\");\r\n        return this;\r\n    }\r\n    size(value) {\r\n        let height, width;\r\n        if (isFunction(value != null ? value.split : void 0)) {\r\n            [width, height] = value.split('x');\r\n            this.width(width);\r\n            return this.height(height);\r\n        }\r\n    }\r\n    sourceTypes(value) {\r\n        this.param(value, \"source_types\");\r\n        return this;\r\n    }\r\n    sourceTransformation(value) {\r\n        return this.param(value, \"source_transformation\");\r\n    }\r\n    startOffset(value) {\r\n        this.rangeParam(value, \"start_offset\", \"so\");\r\n        return this;\r\n    }\r\n    streamingProfile(value) {\r\n        this.param(value, \"streaming_profile\", \"sp\");\r\n        return this;\r\n    }\r\n    transformation(value) {\r\n        this.transformationParam(value, \"transformation\", \"t\");\r\n        return this;\r\n    }\r\n    underlay(value) {\r\n        this.layerParam(value, \"underlay\", \"u\");\r\n        return this;\r\n    }\r\n    variable(name, value) {\r\n        this.param(value, name, name);\r\n        return this;\r\n    }\r\n    variables(values) {\r\n        this.arrayParam(values, \"variables\");\r\n        return this;\r\n    }\r\n    videoCodec(value) {\r\n        this.param(value, \"video_codec\", \"vc\", Param.process_video_params);\r\n        return this;\r\n    }\r\n    videoSampling(value) {\r\n        this.param(value, \"video_sampling\", \"vs\");\r\n        return this;\r\n    }\r\n    width(value) {\r\n        this.param(value, \"width\", \"w\", () => {\r\n            if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\r\n                return Expression.normalize(value);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        });\r\n        return this;\r\n    }\r\n    x(value) {\r\n        this.param(value, \"x\", \"x\", Expression.normalize);\r\n        return this;\r\n    }\r\n    y(value) {\r\n        this.param(value, \"y\", \"y\", Expression.normalize);\r\n        return this;\r\n    }\r\n    zoom(value) {\r\n        this.param(value, \"zoom\", \"z\", Expression.normalize);\r\n        return this;\r\n    }\r\n}\r\n/**\r\n * Transformation Class methods.\r\n * This is a list of the parameters defined in Transformation.\r\n * Values are camelCased.\r\n */\r\nconst methods = [\r\n    \"angle\",\r\n    \"audioCodec\",\r\n    \"audioFrequency\",\r\n    \"aspectRatio\",\r\n    \"background\",\r\n    \"bitRate\",\r\n    \"border\",\r\n    \"color\",\r\n    \"colorSpace\",\r\n    \"crop\",\r\n    \"customFunction\",\r\n    \"customPreFunction\",\r\n    \"defaultImage\",\r\n    \"delay\",\r\n    \"density\",\r\n    \"duration\",\r\n    \"dpr\",\r\n    \"effect\",\r\n    \"else\",\r\n    \"endIf\",\r\n    \"endOffset\",\r\n    \"fallbackContent\",\r\n    \"fetchFormat\",\r\n    \"format\",\r\n    \"flags\",\r\n    \"gravity\",\r\n    \"fps\",\r\n    \"height\",\r\n    \"htmlHeight\",\r\n    \"htmlWidth\",\r\n    \"if\",\r\n    \"keyframeInterval\",\r\n    \"ocr\",\r\n    \"offset\",\r\n    \"opacity\",\r\n    \"overlay\",\r\n    \"page\",\r\n    \"poster\",\r\n    \"prefix\",\r\n    \"quality\",\r\n    \"radius\",\r\n    \"rawTransformation\",\r\n    \"size\",\r\n    \"sourceTypes\",\r\n    \"sourceTransformation\",\r\n    \"startOffset\",\r\n    \"streamingProfile\",\r\n    \"transformation\",\r\n    \"underlay\",\r\n    \"variable\",\r\n    \"variables\",\r\n    \"videoCodec\",\r\n    \"videoSampling\",\r\n    \"width\",\r\n    \"x\",\r\n    \"y\",\r\n    \"zoom\"\r\n];\r\n/**\r\n * Parameters that are filtered out before passing the options to an HTML tag.\r\n *\r\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\r\n */\r\nconst PARAM_NAMES = methods.map(snakeCase).concat(CONFIG_PARAMS);\r\nexport default Transformation;\r\n"]},"metadata":{},"sourceType":"module"}